# КР1 КПО
Это учебный проект, реализующий модуль «Учет финансов» для консольного приложения. Проект позволяет создавать, редактировать и удалять основные доменные сущности:
- **BankAccount** (банковский счёт)
- **Category** (категория: доход или расход)
- **Operation** (операция: доход или расход)

Также реализована базовая аналитика, которая вычисляет:
- Общий баланс всех счетов
- Средние доходы и траты за месяц
- Топ-3 категорий расходов

В рамках решения мы внесли следующие изменения в функциональные требования:
- Использование последовательных числовых идентификаторов (int) вместо GUID.
- Обновление баланса счёта осуществляется через вызовы методов `Deposit()` и `Withdraw()`, так как свойство `Balance` имеет закрытый сеттер.
- Вся бизнес-логика разбита на отдельные слои: доменные сущности, фабрики, сервисы и репозитории (работают in-memory).

---

## 1. Общая идея решения

Приложение предоставляет консольное меню для управления финансовыми данными. Пользователь может:
- Создавать банковские счета, категории и операции;
- Просматривать баланс конкретного счета;
- Выводить данные всех счетов, операций и категорий;
- Получать аналитику по финансовым операциям.

Бизнес-логика реализована в доменных сервисах, которые используют единый класс-фабрику для создания объектов и in-memory репозитории для хранения данных. Это позволяет легко тестировать и расширять систему.

---

## 2. Реализованные принципы SOLID и GRASP

### SOLID

- **SRP (Принцип единственной ответственности):**  
  Доменные сущности (BankAccount, Category, Operation) отвечают за представление данных, а сервисы (BankAccountService, CategoryService, OperationService, AnalyticsService) – за бизнес-логику.  
  _Пример:_ Класс `BankAccount` отвечает только за хранение данных и обновление баланса через методы `Deposit()`/`Withdraw()`.

- **OCP (Принцип открытости/закрытости):**  
  Система разработана таким образом, что новые функциональности (например, дополнительные аналитические отчёты) можно добавить без изменения уже существующего кода.  
  _Пример:_ Добавление новых сервисов возможно без модификации доменных сущностей.

- **LSP (Принцип подстановки Лисков):**  
  Использование абстрактных интерфейсов, таких как `IRepository<T>`, позволяет подменять реализации (например, in-memory или для базы данных) без нарушения работы бизнес-логики.

- **ISP (Принцип разделения интерфейсов):**  
  Интерфейсы, например, `IRepository<T>`, определяют минимально необходимый набор методов, что позволяет классам реализовывать только необходимые для них методы.

- **DIP (Принцип инверсии зависимостей):**  
  Сервисы зависят от абстракций (интерфейсов репозиториев и фабрик), а не от конкретных реализаций. Все зависимости внедряются через DI-контейнер.

### GRASP

- **High Cohesion / Low Coupling:**  
  Каждый модуль (сущности, фабрики, сервисы, репозитории) имеет чётко определённую ответственность, что облегчает сопровождение и расширение системы.

- **Controller / Information Expert:**  
  Сервисы, такие как `OperationService`, выступают в роли контроллеров, координирующих создание объектов через фабрику и взаимодействие с репозиториями.

---

## 3. Реализованные паттерны GoF

### Фабрика (Factory)

- **Реализация:**  
  Фабрики для каждого доменного класса в папке *Domain/Factories* отвечают за создание объектов: `BankAccount`, `Category` и `Operation`.  
- **Важность:**  
  Фабрика централизует логику создания и валидации входных данных, предотвращая дублирование кода в сервисах.

### Фасад (Facade)

- **Реализация:**  
  Доменные сервисы (*BankAccountService*, *CategoryService*, *OperationService*, *AnalyticsService* в папке *Domain/Services*) предоставляют простой интерфейс для взаимодействия с бизнес-логикой и скрывают детали работы с репозиториями и фабриками.
- **Важность:**  
  Фасады упрощают взаимодействие с системой, делая её использование понятным для верхнего уровня (например, консольного приложения).

---
